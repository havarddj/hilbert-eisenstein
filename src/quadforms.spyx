import time
# import Cython.Compiler.Options
# Cython.Compiler.Options.annotate = True
from sage.all import *
# from sage.rings.rational import Rational

def Delta_data(Q, int m):
    """For a fixed qf Q and an upper bound m, return a list L of
    length m where each L[m] is a list of forms [Qm] similar to
    the output nr_forms of get_RM_set

    # 05/07/22: updated to get forms, not norms
    Note that this corresponds to the magma function Diagonal_Restriction_Data
    """
    
    F_pos_1, F_neg_1, forms_1 = get_RM_set(1,1,[[list(Q),[[1,0],[0,1]]]])
    forms = [forms_1]
    Fs = [[F_pos_1, F_neg_1]]
    for n in range(2,m):         # n = 2,...,m-1
        p = min(divisors(n)[1:]) # smallest prime divisor (note m != 1)
        d = ZZ(n/(p**(valuation(n,p))))
        F_pos_n, F_neg_n, forms_n = get_RM_set(n,d,forms[d-1])
        forms.append(forms_n)
        Fs.append([F_pos_n, F_neg_n])
        
    return([Fs, forms])
        
        
def get_RM_set(int n, int d, list forms_d):
    r"""Compute the set of RM-points RM(n, tau)_f using algorithm from
    [lauder-vonk2021]_

    Input:
    - $n$ a positive integer.
    - forms_old, a list of pairs [Q_d,delta_d], where Q_d is a quadratic form of discriminant d^2 *D, and delta_d a "Hecke matrix" of determinant d

    #
    Output: 
    - 

    Note that the norm of the ideal corresponding to F is precisely
    the first coefficient, a, which is required to be coprime to $f$.
    # 05/07/22 - updated bits and bobs for anti-parallel business
    Corresponds to magma function RM_Points
    """
    ######
    # Compute Hecke matrices:
    assert n % d == 0
    Hecke_nd = Hecke_matrices(n/d)

    # Initialise some data:

    # start_time = time.time()
    cdef list forms_n = []
    cdef list F_pos_n = []
    cdef list F_neg_n = []

    MQ = MatrixSpace(QQ,2)
    MZ = MatrixSpace(ZZ,2)    

    for Q_d, delta_d in forms_d:
        for H in Hecke_nd:
            Q_n = BinaryQF(Q_d)*MZ(H)
            delta_n = MZ(delta_d)*MZ(H)
            assert delta_n.determinant() == n
            
            # test if our buddy is equivalent to a
            # previously computed friendo:
            already_seen = False

            for Q_n_old, delta_n_old in forms_n:
                E = are_equivalent_mat(Q_n_old, list(Q_n))
                # if Q_n_old and Q_n are equivalent over \Q, this computes
                # the matrix E in SL2(Q) such that Q*E = Q_new
                # if they are not, returns False
                if E:
                    assert MZ(E).determinant() == 1
                    if MQ(delta_n_old)*MQ(E)*MQ(delta_n)**(-1) in MZ:
                        already_seen = True
                        break
                        # No point in continuing if we found buddy-guy

            # if Q_n is not equivalent to something seen before, add it, along with the NR forms in its cycle;
            if not already_seen:
                forms_n.append([list(Q_n), delta_n])
                F_p, F_m, F = nearly_reduced_forms(Q_n)
                # F_p, F_m, F = magma_algo(Q_n)
                F_pos_n += F_p
                F_neg_n += F_m
                
    # end_time = time.time()
    # print(f'Computing RM sets took {end_time - start_time} seconds')
    return([F_pos_n, F_neg_n, forms_n])

# cdef bint equivalent_pairs(list A, list B):
def are_equivalent_mat(Q1, Q2):
    """ Return False if Q1 and Q2 are not equivalent under SL2(Q), otherwise
    return matrix M such that Q1*M =  Q2
    """
    S = Matrix(ZZ,[[1,0],[0,1]])
    if Q1 == Q2:
        return S.rows()
    
    F1, U1 = BinaryQF(Q1).reduced_form(transformation=True)
    F2, U2 = BinaryQF(Q2).reduced_form(transformation=True)
    F = F1

    
    sqrtD = ZZ(floor(F.discriminant().sqrt(prec=30)))
    while F != F2:
        a,b,c = list(F)
        if abs(c) >= sqrtD:
            s = sign(c) * floor(b/(2*abs(c)))
        else:
            s = sign(c) * floor((sqrtD+b) / (2*abs(c)))

        Ms = Matrix(QQ,[[0,-1],[1,s]])
        S = S*Ms
        F = F*Ms
        # if we run through the cycle and don't find F2, then they are not equivalent
        if F == F1:              
            return False
    assert BinaryQF(Q1)*(U1*S*U2**-1) == BinaryQF(Q2)
    return (U1*S*U2**-1).rows()


def nearly_reduced_forms(Q):
    Q0 = Q.reduced_form()
    Q = Q0                      # no need to keep info about Q

    sqrtD = Q.discriminant().sqrt(50)
    cdef list forms_p = []
    cdef list forms_m = []
    cdef list forms = []
    cdef bint started = False
    cdef int a,b,c,s,j
    while Q != Q0 or not started:
        started = True
        Q = Q._Rho()            # set Q to be next reduced form in cycle
        a,b,c = list(Q)
        # now compute s, number of forms on river between previous F and F:
        if abs(c) > sqrtD:
            s = abs(floor(b/(2*abs(c))))
        else:
            s = abs(floor((sqrtD+b)/(2*abs(c))))
        
        if a > 0:                                 # ensure form added has a>0
            for j in range(1,s+1):
                A = a + j*b + c*j**2 
                B = b + 2*j*c
                C = c
                assert A*C < 0
                forms_p.append([A,B,C])
                forms_m.append([C,-B,A])
                forms.append([A,B,C])
        if a < 0:
            for j in range(1,s+1):
                A = c
                B = -b+2*j*c
                C = a-j*b + c*j**2
                assert A*C < 0
                forms_p.append([A,B,C])
                forms_m.append([C, -B, A])
                forms.append([A, B, C])
        
    return [forms_p, forms_m,forms]
                
def Hecke_matrices(int n, Q = False):
    # print(f"Computing Hecke matrices for n = {n}")
    # start_time = time.time()
    # print(n)
    if Q:
        M2Z = MatrixSpace(ZZ,2,2)
        D,N = Q.discriminant(), Q.conductor()
    else:
        N = 0

    cdef int d
    cdef list Mn = []
    for d in divisors(n):
        for j in range(d):  # j= 0,...d-1
            H = [[d,j], [0,n/d]]
            if n == N > 1:
                if any(Q.is_equivalent(Q0.matrix_action_right(M2Z(H))) for Q0 in BinaryQF_reduced_representatives(D/N**2)):
                    # print(f"removed {H}")  # 
                    pass
                else:
                    Mn.append(H)
            else:
                Mn.append(H)
    return(Mn)
                
cpdef list tp_elts_of_trace_n(F, int n, invDiff, int bd):
    """Returns list of totally positive elements of the inverse
    different of F of trace n"""
    a = F.gens()[0]
    # cdef int bd = floor(n*a)
    cdef int b
    cdef list nulist = []
    for b in range(-bd-1,bd+1):
        nu = (b + n*a)/(2*a)
        if nu > 0 and (-b + n*a)/(2*a) >0 and nu in invDiff:
            nulist.append(nu)
        # if F.ideal(nu).is_coprime(m):

    
    # return([(b + n*a)/(2*a) for b in [-bd..bd]])
    return(nulist)

def magma_algo(F):
    """Should correspond to nearly_reduced_forms, but translation of
    the magma algo, so spits out A+-
    05/07/22: updated to match (updated) magma algorithm which actually does forms, not just As
    """
    F0 = F.reduced_form()
    cdef list Fs = []
    F = F0
    cdef list Fs_p = []
    cdef list Fs_m = []
    
    started = False             # run at least once
    while F != F0 or not started:
        started = True
        a, b, c = list(F)
        F = F._Rho()
        s = abs((b + F[1])/(2*c))
        if a > 0:
            for i in range(1,s+1):  # = 1,...,s 
                A = a + i*b + c*i**2 
                B = b + 2*i*c
                C = c
                assert A*C < 0
                Fs_p.append([A,B,C])
                Fs_m.append([C,-B,A])
                Fs.append([A,B,C])
        if a < 0:
            for i in range(1,s+1):
                A = c
                B = -b+2*i*c
                C = a-i*b + c*i**2
                assert A*C < 0
                Fs_p.append([A,B,C])
                Fs_m.append([C, -B, A])
                Fs.append([A, B, C])
    return [Fs_p,Fs_m,Fs]

def bad_Hecke_matrices(Q):
    """If Q is nonfundamental and can be written as Hecke matrix applied to Q0 of fundamental discriminant, return
    list of matrices H such that Q is equivalent to Q0.H
    """
    D, N = Q.discriminant(), Q.conductor()
    if N ==1:
        return []

    HM = Hecke_matrices(N)
    M2Z = MatrixSpace(ZZ,2,2)

    bad_matrices = []
    for Q0 in BinaryQF_reduced_representatives(D/(N**2)):
        for H in HM:
            if Q.is_equivalent(Q0.matrix_action_right(M2Z(H))):
                bad_matrices.append(H)

    return bad_matrices
    
