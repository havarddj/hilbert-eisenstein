def Qp2split(a):
    # return x,y in Qp where a = x + ky for k a generator of K = a.parent()
    K = a.parent()
    p = K.prime()
    m = a.precision_absolute()
    F = Qp(p, m)
    x = F(0)
    y = F(0)
    e = a.expansion()
    for n in [0..m - 1]:
        # for some ridiculous reason the length of a[n] depends on
        # whether or not the corresponding coefficient is non-zero,
        # instead of simply having entries equal to zero
        if len(e[n]) > 0:
            x += e[n][0] * p ^ n
        if len(e[n]) == 2:
            y += e[n][1] * p ^ n

    return (x, y)


def algdepQp(a, d):
    # algebraic recognition of algebraic number/Q of degree d from
    # approximation in Qp

    P = 0
    Qp = a.parent()
    p = Qp.prime()
    m = a.precision_absolute()
    N = p ^ ((5 * m / 7).floor())
    M = copy(zero_matrix(RR, d + 2, d + 2))

    for j in [0..d]:
        M[j, j] = 1
        M[j, d + 1] = QQ(a ^ j)
    M[d + 1, d + 1] = N

    short_vec = M.LLL()[0][:]
    return sum(x ^ i * short_vec[i] for i in [0..d])


def algdepQp2(a, d):
    # algebraic recognition of algebraic number/Q of degree d from
    # approximation in Qp2 (deg 2 unramified ext of Qp)

    P = 0
    K = a.parent()
    p = K.prime()
    m = a.precision_absolute()
    N = p ^ ((5 * m / 7).floor())
    M = copy(zero_matrix(RR, d + 3, d + 3))

    for j in [0..d]:
        M[j, j] = 1
        c1, c2 = Qp2split(a ^ j)

        M[j, d + 1] = QQ(c1)
        M[j, d + 2] = QQ(c2)

    M[d + 1, d + 1] = N
    M[d + 2, d + 2] = N
    print(M)
    short_vec = M.LLL()[0][:]
    return sum(x ^ i * short_vec[i] for i in [0..d])


def GS_algdep(a, deg, Lvals):
    P = 0
    Fp = a.parent()
    p = Kp.prime()
    print(f"p equals {p}")
    m = a.precision_absolute()
    N = p ^ ((5 * m / 7).floor())
    Lpos = sorted([l for l in Lvals if l >= 0],
                  reverse=True)  # eg [1,3,8] from [1, 3, -3, 8, -1]
    print(Lpos)
    partial_sums = [sum(Lpos[-i:]) for i in [1..len(Lpos)]]  # eg [12,11,8]

    d = ZZ(deg / 2)
    assert len(partial_sums) == d
    # primitive p^2-1 th root of 1 in Qp^2
    zeta = cyclotomic_polynomial(p ^ 2 - 1).roots(Fp)[0]

    for k in [0..p ^ 2 - 1]:
        b = a * zeta ^ k

        M = copy(zero_matrix(RR, d + 3, d + 3))
        for j in [0..d]:
            M[j, j] = 1
            if j == d:
                cj = b ^ d
            else:
                cj = QQ(p ^ partial_sums[d - j] * (b ^ j + b ^ deg - j))
            x, y = Qp2split(cj)
            M[j, d + 1] = ZZ(x)  # get 1st component
            M[j, d + 2] = ZZ(y)  # and 2nd component

        M[d + 1, d + 1] = N
        M[d + 2, d + 2] = N
        Mnew = M.LLL()  # LLL outputs new basis which hopefully is good
        P1 = x ^ d * Mnew[0][d]  # start with the middle coeff
        for j in [0..d - 1]:
            c = Mnew[0][j].floor()
            P1 += QQ(p ^ partial_sums[d - j]) * c * (x ^ j + x ^ (deg - j))

            print(f"P1 = {P1} has first coeff {P1[0].factor()}")
        if P1[0] < 0:
            P1 = -P1
        P1 = P1 / gcd(list(P1))
        if is_power_of_p(P1[0], p) and P1[d] != 0:
            P = P1

    return P
