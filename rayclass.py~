from sage.groups.abelian_gps.values import AbelianGroupWithValues_class, AbelianGroupWithValuesElement
class RayClassCharacterGroup(AbelianGroupWithValues_class, UniqueRepresentation):
    """
    """
    Element = RayClassCharacter
    def __init__(self, number_field, discriminant=1):
        """
        Create character group
        """
        self.number_field = number_field
        self.ray_class_group =
        self.modulus = 

class RayClassCharacter (AbelianGroupWithValuesElement):
    """
    """

    def __init__(self, parent,element,):
        if element is None:
            element = parent._ideal_log(ideal)
        AbelianGroupWithValuesElement.__init__(self, parent, element, ideal)

    def _mul_(self, other):
        m = AbelianGroupElement._mul_(self, other)
        m._value =              # todo
        return m

    def _div_(self, other):
        d = AbelianGroupElement._mul_(self, other)
        m._value =              #
        return m

    def __pow__(self, n):
        # We use MonoidElement's __pow__ routine, since that does
        # repeated squaring, and hence the ideal gets reduced as
        # we go along; actually computing self._value ** n would
        # be disastrous.
        n = n % self.order()
        return MonoidElement.__pow__(self, n)

    def inverse(self):
        r"""
        Return the multiplicative inverse of this ideal class.

        EXAMPLES::

            sage: K.<a> = NumberField(x^3 - 3*x + 8); G = K.class_group()
            sage: G(2, a).inverse()
            Fractional ideal class (2, a^2 + 2*a - 1)
            sage: ~G(2, a)
            Fractional ideal class (2, a^2 + 2*a - 1)
        """
        m = AbelianGroupElement.inverse(self)
        m._value =              # 
        return m
    __invert__ = inverse
