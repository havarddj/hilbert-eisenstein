

# This file was *autogenerated* from the file /home/havard/Projects/HilbertEisenstein/worksheet.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_4 = Integer(4); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_12 = Integer(12); _sage_const_7 = Integer(7); _sage_const_6 = Integer(6)
def diagonal_restriction_Lp(F, p, k0, psi, m, verbose=False, RM=False):
    """Compute p-adic L-function L_p(psi,s) as polynomial in s using
    diagonal restriction.
    Currently only works for F real quadratic

    """
    d = F.degree()
    assert d == _sage_const_2 , "only quadratic fields supported atm"
    # assert F(p).is_prime(), "only p inert supported atm"
    if p == _sage_const_2 :
        q = _sage_const_4 
        deltam = m
        kj = [k0+j*_sage_const_2  for j in (ellipsis_range(_sage_const_0 ,Ellipsis,deltam))]
    else:
        q = p
        deltam = ceil(m*(p-_sage_const_1 )/(p-_sage_const_2 ))
        kj = [k0+j*(p-_sage_const_1 ) for j in (ellipsis_range(_sage_const_0 ,Ellipsis,deltam))]

    # print('deltam')
    mfrak = psi.modulus()
    M = mfrak.finite_part().smallest_integer()
   
    R = PowerSeriesRing(QQ, names=('Z',)); (Z,) = R._first_ngens(1)
    Zpp = Zp(p, prec=deltam+_sage_const_1 , type='capped-rel', print_mode='val-unit')
    Qpp = Zpp.fraction_field()
    Psi = hecke_to_dirichlet_char(psi, M)

    Mtop =  ModularForms(Psi, weight=d*kj[deltam])
    S = Mtop.sturm_bound()
    K = Mtop.base_ring()
    if verbose:
        print("Sturm bound:", S)
        print("Weights:", kj)
        print("delta_m =", deltam)
        print("Psi =", Psi)
        print("Base field:", K)
    Mdkj = [ModularForms(Psi, weight=(d*kj[j])).q_expansion_basis(prec=S) for j in
        (ellipsis_range(_sage_const_0 ,Ellipsis,deltam))]
    if verbose:
        print("dims of M_{k_j}:", [len(Mdkj[m]) for m in (ellipsis_range(_sage_const_0 ,Ellipsis,deltam))])
    # print(len(Mdkj))
    # for basis in Mdkj:
    #     print(len(basis))


    # We compute the non-constant coefficients of the diagonal
    # restrictions, all in one go (i.e. \Delta_j for j = 0,...,delta_m)
    if verbose:
        print("Computing diagonal restrictions:")
    Deltaj = []

    Diff = F.different()
    # if psi.is_trivial():
        # for j in [0..deltam]:
        #     Deltaj.append(2^d*sum(Z^n * sum(A.norm()^(kj[j]-1) for nu in
        #                                 tp_elts_of_trace_n(F,n) for A in
        #                                 divisors(nu*Diff)
        #                                 ) for n in [1..S-1]))
    # else:
    mfin = mfrak.finite_part()
    for j in (ellipsis_range(_sage_const_0 ,Ellipsis,deltam)):
        Deltaj.append(_sage_const_2 **d*sum(Z**n * sum(psi(A)*A.norm()**(kj[j]-_sage_const_1 )
                                        for nu in
                                        tp_elts_of_trace_n(F, n, mfrak.finite_part())
                                        for A in divisors(nu*Diff) if A.is_coprime(mfin))
                              for n in (ellipsis_range(_sage_const_1 ,Ellipsis,S-_sage_const_1 ))))
    if verbose:
        print("Higher coefficients of Delta_{k_0}:", Deltaj[_sage_const_0 ])
    # Using some linear algebra, we find the constant terms, which are
    # classical L-values; viz. const term(Delta_j) = L(psi,1-k_j)
    Ls = [find_const_term(Mdkj[j], Deltaj[j], field=K) for j in (ellipsis_range(_sage_const_0 ,Ellipsis,deltam))]
    # For psi trivial, we compare the zeta values with their numerical value from the
    # analytic expression:
    if psi.is_trivial() and verbose:
        zeta = F.zeta_function()
        # assert [L.n() for L in Ls] == [zeta(1-kj[j]) for j in [0..deltam]], \
        #     "classical L-values are incorrect"
        print("Sum of zeta errors:", sum(abs(Ls[j]-zeta(_sage_const_1 -kj[j])) for j in (ellipsis_range(_sage_const_0 ,Ellipsis,deltam))))

    if verbose:
        print("Classical L-values:", Ls)
    Lsp = [Zpp(Ls[j]*(Euler_factor(F, p, psi, kj[j]))) for j in (ellipsis_range(_sage_const_0 ,Ellipsis,deltam))]
    if verbose:
        print("p-adic L-values:", Lsp)
    # R.<Z> = PolynomialRing(QQ)
    # R = Zp(p, prec=m)
    # S.<s> = PolynomialRing(R)



    # Compute the Newton interpolation polynomial from the special
    # values (1-k,L_p(psi,1-k)):

    if verbose:
        print("x-coordinates of interpolation points in s:", [_sage_const_1 -k for k in kj], "\n \n")
    points = [[_sage_const_1 -kj[j], Zpp(Lsp[j])] for j in (ellipsis_range(_sage_const_0 ,Ellipsis,deltam))]
    P = Newton_poln(points)
    if verbose:
        print("P(s) = ", P, "\n \n")

    T_coords = [(_sage_const_1 +p)**(_sage_const_1 -k) - _sage_const_1  for k in kj]
    if verbose:
        print("x-coordinates of interpolation points in T:", T_coords, "\n \n")
    pointsnew = [(T_coords[j], R(Lsp[j])) for j in (ellipsis_range(_sage_const_0 ,Ellipsis,deltam))]
    PolnQp = PolynomialRing(Zpp.fraction_field(), names=('T',)); (T,) = PolnQp._first_ngens(1)
    Q = PolnQp(Newton_poln(pointsnew))
    # print(points)

    if verbose:
        print("Q(T) = ", Q)
    return(P, Q)


def Euler_factor(F, p, psi, kj):
    r"""Return $\prod_{\mathfrak p | (p)}(1-\psi(\mathfrak p)
    \mathrm{Nrm}(\mathfrak p)^{k_j-1})$

    for psi trivial, F quadratic, this equals 1-p^(2(k_j-1)) if p is inert, 1-
    """
    # for now, assume :
    if F.discriminant() % p == _sage_const_0 :
        return _sage_const_1  - psi(p)*p**(kj-_sage_const_1 )     # p ramified
    else:
        return prod(_sage_const_1 -psi(pf[_sage_const_0 ])*pf[_sage_const_0 ].norm()**(kj-_sage_const_1 ) for pf in F.ideal(p).factor())
    
    # elif F(p).is_prime():
    #     return 1-psi(p)*p^(2*(kj-1))   # p inert

    # return (1-psi(p)*p^(kj-1))^2       # p split
    
    
    # if not F.conductor() % p:
    #     return 0



def hecke_to_dirichlet_char(psi,M):
    """Given Hecke character psi with modulus mfrak such that mfrak
    \cap Z = (M), return associated Dirichlet character mod M, Psi 

    """
    # assert M == psi.modulus().finite_part().smallest_integer()
    D = DirichletGroup(M)
    gens = D.unit_gens()
    return D([psi(g) for g in gens])


def tp_elts_of_trace_n(F, n, m):
    """Returns list of totally positive elements of the inverse
    different of F of trace n whice are coprime to m, an ideal of F"""
    a = F.gens()[_sage_const_0 ]
    bd = floor(n*a)
    # nulist = []
    # for b in [-bd..bd]:
    #     nu = (b + n*a)/(2*a)
    #     if F.ideal(nu).is_coprime(m):
    #         nulist.append(nu)
    
    return([(b + n*a)/(_sage_const_2 *a) for b in (ellipsis_range(-bd,Ellipsis,bd))])



def find_const_term(M, f, field=QQ):
    """given a q-expansion basis M, and f a q-expansion in M with
    missing constant term, find constant term of f.
    """
    R = PowerSeriesRing(field, names=('Z',)); (Z,) = R._first_ngens(1)
    A = [R(M[j]).padded_list()[_sage_const_1 :] for j in (ellipsis_range(_sage_const_0 ,Ellipsis,len(M)-_sage_const_1 ))]
    Mat = Matrix(field, A)
    try:
        soln = Mat.transpose()  * BackslashOperator() * vector(field, f.padded_list()[_sage_const_1 :])
    except ValueError:
        print("not in space of forms")
        return(_sage_const_0 )
    CT = (sum(soln[n]*M[n] for n in (ellipsis_range(_sage_const_0 ,Ellipsis,len(M)-_sage_const_1 ))))[_sage_const_0 ]
    return(CT)

def Newton_poln(points):
    """Return Newton interpolation polynomial, computed using divided differences. Input is a list of tuples points = [(x_0,y_0),(x_1,y_1),...,(x_n,y_n)]. The resulting polynomial P is of degree n and satisfies P(x_i) = y_i for every tuple in points"""
    K = parent(points[_sage_const_0 ][_sage_const_1 ]).fraction_field()
    n = len(points)
    coefs = copy(zero_matrix(K, n))
    for i in range(n):
        coefs[i,_sage_const_0 ] = points[i][_sage_const_1 ]
    for j in (ellipsis_range(_sage_const_1 ,Ellipsis,n)):
        # print("j=",j)
        for i in (ellipsis_range(_sage_const_0 ,Ellipsis,n-j-_sage_const_1 )):
            # print("i=", i)
            coefs[i, j] = (coefs[i+_sage_const_1 , j-_sage_const_1 ] - coefs[i, j-_sage_const_1 ]) / (points[i+j][_sage_const_0 ]-points[i][_sage_const_0 ])
    R = PolynomialRing(K, names=('s',)); (s,) = R._first_ngens(1)
    P = sum(coefs[_sage_const_0 ][i]*prod((s-points[j][_sage_const_0 ]) for j in (ellipsis_range(_sage_const_0 ,Ellipsis,i-_sage_const_1 ))) for i in (ellipsis_range(_sage_const_0 ,Ellipsis,n-_sage_const_1 )))
    return P


# def forward_diff(i, L):
#     """Return Delta^i (f(x_0)) where L is a list of pairs (x_j,
#     f(x_j)) with x_j - x_(j-1) = h for all j"""
#     return(sum((-1)^(i-j)*binomial(i,j)*L[j][1] for j in [0..i]))
    # S.<s> = PolynomialRing(QQ)
    # h = points[1][0] - points[0][0]
    # assert h == (points[2][0] - points[1][0])
    # return(sum(forward_diff(i, points) * prod(s - points[0][0] -k for k in [0..i-1])/factorial(i) for i in [0..len(points)-1]))

# def diagonal_restriction_Lp(F, p, k0, psi, m):

#     # F.<a> = NumberField(x^3-3*x-1)

#     if not F.is_totally_real():
#         print("F is not totally real!")

#     d = F.degree()
#     if d > 3:
#         return("degree too high for now")

#     Psi = psi
#     M = m
#     # deltam = 24
#     deltam = ceil(m*(p-1)/(p-2))
    
#     kj = [2+j*(p-1) for j in [0..deltam]]  # note k0 = 2 as above

#     S = ModularForms(Psi,d*kj[deltam]).sturm_bound()
#     print(S)
#     # Mdkj = [ModularForms(Psi, d*kj[j], base_ring=QQ).q_expansion_basis()
#     #     for j in [0..deltam]]
#     # To compute q-expansions more efficiently, we should probably use
#     # Alan's algorithm

#     # return(compute_Delta_j(psi, S, deltam, d, kj, p))
#     R.<q> = PowerSeriesRing(QQ)
#     DeltaList = []
#     mfrak = psi.conductor()
#     QFlist = BinaryQF_reduced_representatives(mfrak)
#     print(QFlist)
#     for Q in QFlist:
#         RMlist = []
#         for n in [1..S-1]:
#             # print(n)
#             RMset = get_RM_set(n, Q)
#             # print(RMset)
#             if len(RMset) !=0:
#                 RMlist.append(RMset)
#         print("Computed RM sets \n")
#         for j in [0..deltam]:
#             Delta = 0
#             for n in [1..S-1]:
#                 for l in [0..len(RMlist)-1]:
#                     RM = RMlist[l]
#                     print(RM[0])
#                     if RM != []:
#                         Q2 = RM[0]
#                         tau = stable_root(Q2[0])
#                         print(tau)
#                         Delta += q^n *2^d*psi(tau)*Q2[0][0]^(kj[j]-1)
#         DeltaList.append(Delta)
#     print("Computed Delta Q = ", Q)

#     return(DeltaList)
#     # Clean this up into consecutive computations

# Using some pari functions to compute ray class groups
# Note; we don't need to use the gp wrapper

# # load("rayclass.py") 
from sage.libs.pari.all import pari, pari_gen
def conductor(O):
    f = O.index_in(O.number_field().maximal_order())
    return(f)

def order_narrow_class_group(O):
    # if O.is_maximal():
    #     return(O.narrow_class_group())
    P = pari(O.number_field().pari_polynomial())
    f = conductor(O)
    r1 = O.number_field().signature()[_sage_const_0 ]
    # # k = O.number_field().pari_bnf(flag=1)
    # bnf = pari.bnfinit(P,flag=1)
    # bnr = pari.bnrinit(bnf,Pari(conductor(O)),flag=1)
    # Cl = pari("bnf.")
    L = pari("bnrinit(bnfinit({}),[{},{}],1).cyc".format(P, f, [_sage_const_1  for n in (ellipsis_range(_sage_const_1 ,Ellipsis,r1))]))
    # The list in the end says that the modulus contains f and all the infinite places
    # cycle_structure = tuple( ZZ(c) for c in k.bnf_get_cyc() )
    if len(L) == _sage_const_0 :
        return(AbelianGroup([_sage_const_1 ]))
    return(AbelianGroup(L))


def mod_narrow_class_group(F,m):
    """
    Takes number field F and integral ideal m, and returns Cl_m^+
    """
    P = F.pari_polynomial()
    r1 = F.signature()[_sage_const_0 ]
    # Initialise pari field
    bnf = pari("bnfinit({})".format(P))
    # For the time being, let's assume m is principal
    # decompose m in pari
    mPari = pari("idealhnf({},{})".format(bnf, m))
    # compute Cl_m^+
    L = pari("bnrinit({bnf},[{mPari},{L}],1).cyc".format(bnf=bnf,mPari=mPari, L=[_sage_const_1  for n in (ellipsis_range(_sage_const_1 ,Ellipsis,r1))]))
    if len(L) == _sage_const_0 :
        return(AdditiveAbelianGroup([_sage_const_1 ]))
    return(AdditiveAbelianGroup(L))

def mod_narrow_ray_char_grp(F,m):
    """
    Takes number field F and integral ideal m, and returns the
    group of characters on Cl_m^+
    """
    P = F.pari_polynomial()
    bnf = pari("bnfinit({})".format(P))
    r1 = F.signature()[_sage_const_0 ]
    mPari = pari("idealhnf({},{})".format(bnf, m))
    bnr = pari("bnrinit({}, [{mPari},{L}],1)".format(bnf, mPari=mPari,
                                                      L=[_sage_const_1  for n in (ellipsis_range(_sage_const_1 ,Ellipsis,r1))]))
    g = pari("[{}.gen[1]]".format(bnr))
    return(pari("bnrchar({},{})".format(bnr, g)))

def get_RM_set(n, Q):
    """
    Compute the set of RM-points RM(n, tau)_f using algorithm from
    [lauder-vonk?]_

    Input:
    - $n$ an integer
    - a reduced binary quadratic form with stable root tau
    Output:
    - the set of augmented RM points of discriminant n^2 D, as a list
      of lists [F,gamma_n] where F is a quadratic form and gamma_n a
      determinant n matrix with integer coeffs

    Note that the norm of the ideal corresponding to F is precisely
    the first coefficient, a.
    """
    D = Q.discriminant()
    D0 = D.squarefree_part()
    f = sqrt(D/D0)
    # First, we do a stupid computation to find possible elements of
    # stabilisers of RMpts
    Stab = []
    for a in (ellipsis_range(-_sage_const_1 ,Ellipsis,_sage_const_1 )):
        for b in (ellipsis_range(-_sage_const_1 ,Ellipsis,_sage_const_1 )):
            for c in (ellipsis_range(-_sage_const_1 ,Ellipsis,_sage_const_1 )):
                for d in (ellipsis_range(-_sage_const_1 ,Ellipsis,_sage_const_1 )):
                    if a*d-b*c == _sage_const_1 :
                        s = Matrix(ZZ,[[a,b],[c,d]])
                        if s**(_sage_const_12 ) == Matrix(ZZ,[[_sage_const_1 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_1 ]]):
                            Stab.append(s)

    Mn = []
    for d in divisors(n):
        if gcd(d, n/d) == _sage_const_1 :
            for j in (ellipsis_range(_sage_const_0 ,Ellipsis,d-_sage_const_1 )):
                Mn.append(Matrix(ZZ,[[n/d,j], [_sage_const_0 ,d]]))

    def is_in_SL2Z(Q, gamman, gnp, Stab):
        # """Returns True if $\gamma_n'\mathrm{Stab(\tau)}\gamma_n^-1
        # \subset \Sl_2(\Z), and false otherwise"""    
        flag = True
        for s in Stab:
            if Q.matrix_action_left(s) == Q:
                Mat = gnp*s*(gamman**-_sage_const_1 )
                for i in (ellipsis_range(_sage_const_0 ,Ellipsis,_sage_const_1 )):
                    for j in (ellipsis_range(_sage_const_0 ,Ellipsis,_sage_const_1 )):
                        if not Mat[i][j].is_integer():
                            flag = False
        return(flag)

    RMn = []
    for k in (ellipsis_range(_sage_const_0 ,Ellipsis,len(Mn)-_sage_const_1 )):
        gamman = Mn[k]
        flag = False                # if True, then there exists some gamma_n'
                                    # for which is_in_SL2Z is true
        for gnp in Mn[:k-_sage_const_1 ]:
            if is_in_SL2Z(Q,gamman, gnp, Stab):
                flag = True
        if not flag:
            Q2 = Q.matrix_action_left(gamman)
            if gcd(f, Q2[_sage_const_0 ]) == _sage_const_1 :
                RMn.append([Q2.reduced_form(), gamman])

    return(RMn)

def stable_root(Q):
    """ Returns stable root of indefinite quadratic form Q
    """
    if Q[_sage_const_0 ] == _sage_const_0 :
        return(_sage_const_0 )
    return((-Q[_sage_const_1 ]+sqrt(Q.discriminant()))/(_sage_const_2 *Q[_sage_const_0 ]))

# def compute_Delta_j(psi, S, deltam, d, kj, p):
#     """Computes non-constant terms of diagonal restriction
#     Input:

#     Output: list where the j-th entry is the power series Delta_j

#     """
#     R.<q> = PowerSeriesRing(QQ)
#     DeltaList = []
#     mfrak = psi.conductor()
#     QFlist = BinaryQF_reduced_representatives(mfrak)
#     print(QFlist)
#     for Q in QFlist:
#         RMlist = []
#         for n in [1..S-1]:
#             # print(n)
#             RMset = get_RM_set(n, Q)
#             # print(RMset)
#             if len(RMset) !=0:
#                 RMlist.append(RMset)
#         print("Computed RM sets \n")
#         for j in [0..deltam]:
#             Delta = 0
#             for n in [1..S-1]:
#                 for l in [0..len(RMlist)-1]:
#                     RM = RMlist[l]
#                     print(RM[0])
#                     if RM != []:
#                         Q2 = RM[0]
#                         print("\psi(0)", psi(F(1)))
#                         Delta += q^n *2^d*psi(F(stable_root(Q2[0])))*Q2[0][0]^(kj[j]-1)
#         DeltaList.append(Delta)
#     print("Computed Delta Q = ", Q)

#     return(DeltaList)
#     # Clean this up into consecutive computations

    # if RM:
    #     R.<Z> = PowerSeriesRing(QQ)
    #     mfrak = 1
    #     QFlist = BinaryQF_reduced_representatives(mfrak)
    #     print(QFlist)
    #     for Q in QFlist:
    #         RMlist = []
    #         for n in [1..S-1]:
    #         # print(n)
    #             RMset = get_RM_set(n, Q)
    #             # print(RMset)
    #             if len(RMset) !=0:
    #                 RMlist.append(RMset)
    #     print("Computed RM sets \n")
    #     for j in [0..deltam]:
    #         Delta = 0
    #         for n in [1..S-1]:
    #             for l in [0..len(RMlist)-1]:
    #                 RM = RMlist[l]
    #                 # print(RM[0])
    #                 if RM != []:
    #                     Q2 = RM[0]
    #                     Delta += Z^n *2^d*Q2[0][0]^(kj[j]-1)
    #                     Deltaj.append(Delta)
    #     # print("Computed Deltaj")
    # else:

if __name__ == "__main__":
    F = NumberField(x**_sage_const_2 -_sage_const_12 , names=('a',)); (a,) = F._first_ngens(1)
    p = _sage_const_7 
    k0 = _sage_const_2 
    m = _sage_const_6 
    r1 = F.signature()[_sage_const_0 ]       # nr of real embeddings = 2
    mfrak = F.modulus(F.ideal(_sage_const_4 ), range(r1))  # narrow class group
    H = HeckeCharacterGroup(mfrak)
    try:
        psi = H.gens()[_sage_const_1 ]
    except:
        psi = H.one()
    # F.dirichlet_group()[0]
    print("F = ", F,
          "\n H = ", H.group(),
          "\np = ", p,
          "\nk0 = ", k0,
          "\nm = ", m,
          "\npsi = ", psi)
    P, Q = diagonal_restriction_Lp(F, p, k0, psi, m, verbose=True)
    # print("P(s) = ", P)
    # print("Q(T) = ", Q)

#     with open('pAdicLvalues.csv', newline='') as csvfile:

