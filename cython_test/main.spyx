from sage.groups.additive_abelian.additive_abelian_group import *
from sage.modular.hecke_character import *
from sage.rings.number_field.number_field import *
def diagonal_restriction_Lp(F, p, k0, psi, m, verbose=False, RM=False):
    """Compute p-adic L-function L_p(psi,s) as polynomial in s using
    diagonal restriction.
    Currently only works for psi trivial, F quadratic

    """
    d = F.degree()
    assert d == 2, "only quadratic fields supported atm"
    # assert F(p).is_prime(), "only p inert supported atm"
    if p == 2:
        q = 4
        deltam = m
        kj = [k0+j*2 for j in [0..deltam]]
    else:
        q = p
        deltam = ceil(m*(p-1)/(p-2))
        kj = [k0+j*(p-1) for j in [0..deltam]]

    # print('deltam')
    mfrak = psi.modulus()
    M = mfrak.finite_part().smallest_integer()
   
    R = PowerSeriesRing(QQ, 'Z')
    # Trivial level, since the trivial character has conductor 1
    S = ModularForms(Gamma1(M), weight=d*kj[deltam]).sturm_bound()
    # TODO: reduce Sturm bound by working with spaces w/ nebentypen
    if verbose:
        print("Sturm bound:", S)
        print("Weights:", kj)
    Mdkj = [ModularForms(Gamma1(M), weight=(d*kj[j])).q_expansion_basis(prec=S) for j in
        [0..deltam]]
    # print(len(Mdkj))
    # for basis in Mdkj:
    #     print(len(basis))


    # We compute the non-constant coefficients of the diagonal
    # restrictions, all in one go (i.e. \Delta_j for j = 0,...delta_m)
    if verbose:
        print("Computing diagonal restrictions:")

    Diff = F.different()
    for j in [0..deltam]:
        Deltaj.append(2^d*sum(Z^n * sum(psi(A)*A.norm()^(kj[j]-1) for nu in
                                    tp_elts_of_trace_n(F,n) for A in
                                    divisors(nu*Diff)
                                    ) for n in [1..S-1]))

    if verbose:
        print("Higher coefficients of Delta_{k_0}:", Deltaj[0])
    # Using some linear algebra, we find the constant terms, which are
    # classical L-values; viz. const term(Delta_j) = L(psi,1-k_j)
    Ls = [find_const_term(Mdkj[j], Deltaj[j]) for j in [0..deltam]]
    # we compare the zeta values with their numerical value from the
    # analytic expression:
    zeta = F.zeta_function()
    # assert [L.n() for L in Ls] == [zeta(1-kj[j]) for j in [0..deltam]], \
    #     "classical L-values are incorrect"
    print("Sum of zeta errors:", sum(abs(Ls[j]-zeta(1-kj[j])) for j in [0..deltam]))

    if verbose:
        print("Classical L-values:", Ls)
    Lsp = [Ls[j]*Euler_factor(F, p, psi, kj[j]) for j in [0..deltam]]
    if verbose:
        print("p-adic L-values:", Lsp)
    # R.<Z> = PolynomialRing(QQ)
    # R = Zp(p, prec=m)
    # S.<s> = PolynomialRing(R)
    R = Zp(p, prec=m+1, type='capped-rel', print_mode='val-unit')


    # Compute the Newton interpolation polynomial from the special
    # values (1-k,L_p(psi,1-k)):

    if verbose:
        print("x-coordinates of interpolation points in s:", [1-k for k in kj], "\n \n")
    points = [[1-kj[j], R(Lsp[j])] for j in [0..deltam]]
    P = Newton_poln(points)
    if verbose:
        print("P(s) = ", P, "\n \n")

    T_coords = [(1+p)^(1-k) - 1 for k in kj]
    if verbose:
        print("x-coordinates of interpolation points in T:", T_coords, "\n \n")
    pointsnew = [(T_coords[j], R(Lsp[j])) for j in [0..deltam]]
    PolnQp = PolynomialRing(R.fraction_field(),'T')
    Q = PolnQp(Newton_poln(pointsnew))
    # print(points)

    if verbose:
        print("Q(T) = ", Q)
    return(P, Q)


def Euler_factor(F, p, psi, kj):
    r"""Return $\prod_{\mathfrak p | (p)}(1-\psi(\mathfrak p)
    \mathrm{Nrm}(\mathfrak p)^{k_j-1})$

    for psi trivial, F quadratic, this equals 1-p^(2(k_j-1)) if p is inert, 1-
    """
    # for now, assume :
    if F.discriminant() % p == 0:
        return 1 - psi(p)*p^(kj-1)     # p ramified
    elif F(p).is_prime():
        return 1-psi(p)*p^(2*(kj-1))   # p inert

    return (1-psi(p)*p^(kj-1))^2       # p split
    
    
    # if not F.conductor() % p:
    #     return 0
    # return prod(1-psi(pf)*pf[0].norm()^(kj-1) for pf in F.ideal(p).factor())




def tp_elts_of_trace_n(F, n):
    """Returns list of totally positive elements of the inverse
    different of F of trace n"""
    L = []
    invDiff = F.different()^-1
    a = F.gens()[0]
    bd = floor(n*a)
    for b in range(-bd, bd):
        nu = (-b + n*a)/(2*a)
        # assert nu.trace() == n
        if nu in invDiff:
            L.append(nu)
    return(L)

def find_const_term(M, f):
    """given a q-expansion basis M, and f a q-expansion in M with
    missing constant term, find constant term of f.
    """
    R = PowerSeriesRing(QQ,'Z')
    A = [R(M[j]).padded_list()[1:] for j in [0..len(M)-1]]
    Mat = Matrix(QQ, A)
    try:
        soln = Mat.transpose().solve_right(vector(QQ, f.padded_list()[1:]))
    except ValueError:
        print("not in space of forms")
        return(0)
    CT = (sum(soln[n]*M[n] for n in [0..len(M)-1]))[0]
    return(CT)

def Newton_poln(points):
    """Return Newton interpolation polynomial, computed using divided differences. Input is a list of tuples points = [(x_0,y_0),(x_1,y_1),...,(x_n,y_n)]. The resulting polynomial P is of degree n and satisfies P(x_i) = y_i for every tuple in points"""
    K = parent(points[0][1]).fraction_field()
    n = len(points)
    coefs = copy(zero_matrix(K, n))
    for i in range(n):
        coefs[i,0] = points[i][1]
    for j in [1..n]:
        # print("j=",j)
        for i in [0..n-j-1]:
            # print("i=", i)
            coefs[i, j] = (coefs[i+1, j-1] - coefs[i, j-1]) / (points[i+j][0]-points[i][0])
    R = PolynomialRing(K,'s')
    P = sum(coefs[0][i]*prod((s-points[j][0]) for j in [0..i-1]) for i in [0..n-1])
    return P


# def forward_diff(i, L):
#     """Return Delta^i (f(x_0)) where L is a list of pairs (x_j,
#     f(x_j)) with x_j - x_(j-1) = h for all j"""
#     return(sum((-1)^(i-j)*binomial(i,j)*L[j][1] for j in [0..i]))
    # S.<s> = PolynomialRing(QQ)
    # h = points[1][0] - points[0][0]
    # assert h == (points[2][0] - points[1][0])
    # return(sum(forward_diff(i, points) * prod(s - points[0][0] -k for k in [0..i-1])/factorial(i) for i in [0..len(points)-1]))

# def diagonal_restriction_Lp(F, p, k0, psi, m):

#     # F.<a> = NumberField(x^3-3*x-1)

#     if not F.is_totally_real():
#         print("F is not totally real!")

#     d = F.degree()
#     if d > 3:
#         return("degree too high for now")

#     Psi = psi
#     M = m
#     # deltam = 24
#     deltam = ceil(m*(p-1)/(p-2))
    
#     kj = [2+j*(p-1) for j in [0..deltam]]  # note k0 = 2 as above

#     S = ModularForms(Psi,d*kj[deltam]).sturm_bound()
#     print(S)
#     # Mdkj = [ModularForms(Psi, d*kj[j], base_ring=QQ).q_expansion_basis()
#     #     for j in [0..deltam]]
#     # To compute q-expansions more efficiently, we should probably use
#     # Alan's algorithm

#     # return(compute_Delta_j(psi, S, deltam, d, kj, p))
#     R.<q> = PowerSeriesRing(QQ)
#     DeltaList = []
#     mfrak = psi.conductor()
#     QFlist = BinaryQF_reduced_representatives(mfrak)
#     print(QFlist)
#     for Q in QFlist:
#         RMlist = []
#         for n in [1..S-1]:
#             # print(n)
#             RMset = get_RM_set(n, Q)
#             # print(RMset)
#             if len(RMset) !=0:
#                 RMlist.append(RMset)
#         print("Computed RM sets \n")
#         for j in [0..deltam]:
#             Delta = 0
#             for n in [1..S-1]:
#                 for l in [0..len(RMlist)-1]:
#                     RM = RMlist[l]
#                     print(RM[0])
#                     if RM != []:
#                         Q2 = RM[0]
#                         tau = stable_root(Q2[0])
#                         print(tau)
#                         Delta += q^n *2^d*psi(tau)*Q2[0][0]^(kj[j]-1)
#         DeltaList.append(Delta)
#     print("Computed Delta Q = ", Q)

#     return(DeltaList)
#     # Clean this up into consecutive computations

# Using some pari functions to compute ray class groups
# Note; we don't need to use the gp wrapper

# # load("rayclass.py") 
from sage.libs.pari.all import pari, pari_gen
def conductor(O):
    f = O.index_in(O.number_field().maximal_order())
    return(f)

def order_narrow_class_group(O):
    # if O.is_maximal():
    #     return(O.narrow_class_group())
    P = pari(O.number_field().pari_polynomial())
    f = conductor(O)
    r1 = O.number_field().signature()[0]
    # # k = O.number_field().pari_bnf(flag=1)
    # bnf = pari.bnfinit(P,flag=1)
    # bnr = pari.bnrinit(bnf,Pari(conductor(O)),flag=1)
    # Cl = pari("bnf.")
    L = pari("bnrinit(bnfinit({}),[{},{}],1).cyc".format(P, f, [1 for n in [1..r1]]))
    # The list in the end says that the modulus contains f and all the infinite places
    # cycle_structure = tuple( ZZ(c) for c in k.bnf_get_cyc() )
    if len(L) == 0:
        return(AbelianGroup([1]))
    return(AbelianGroup(L))


def mod_narrow_class_group(F,m):
    """
    Takes number field F and integral ideal m, and returns Cl_m^+
    """
    P = F.pari_polynomial()
    r1 = F.signature()[0]
    # Initialise pari field
    bnf = pari("bnfinit({})".format(P))
    # For the time being, let's assume m is principal
    # decompose m in pari
    mPari = pari("idealhnf({},{})".format(bnf, m))
    # compute Cl_m^+
    L = pari("bnrinit({bnf},[{mPari},{L}],1).cyc".format(bnf=bnf,mPari=mPari, L=[1 for n in [1..r1]]))
    if len(L) == 0:
        return(AdditiveAbelianGroup([1]))
    return(AdditiveAbelianGroup(L))

def mod_narrow_ray_char_grp(F,m):
    """
    Takes number field F and integral ideal m, and returns the
    group of characters on Cl_m^+
    """
    P = F.pari_polynomial()
    bnf = pari("bnfinit({})".format(P))
    r1 = F.signature()[0]
    mPari = pari("idealhnf({},{})".format(bnf, m))
    bnr = pari("bnrinit({}, [{mPari},{L}],1)".format(bnf, mPari=mPari,
                                                      L=[1 for n in [1..r1]]))
    g = pari("[{}.gen[1]]".format(bnr))
    return(pari("bnrchar({},{})".format(bnr, g)))
# def get_RM_set(n, Q):
#     """
#     Compute the set of RM-points RM(n, tau)_f using algorithm from
#     [lauder-vonk?]_

#     Input:
#     - $n$ an integer
#     - a reduced binary quadratic form with stable root tau
#     Output:
#     - the set of augmented RM points of discriminant n^2 D, as a list
#       of lists [F,gamma_n] where F is a quadratic form and gamma_n a
#       determinant n matrix with integer coeffs

#     Note that the norm of the ideal corresponding to F is precisely
#     the first coefficient, a.
#     """
#     D = Q.discriminant()
#     D0 = D.squarefree_part()
#     f = sqrt(D/D0)
#     # First, we do a stupid computation to find possible elements of
#     # stabilisers of RMpts
#     Stab = []
#     for a in [-1..1]:
#         for b in [-1..1]:
#             for c in [-1..1]:
#                 for d in [-1..1]:
#                     if a*d-b*c == 1:
#                         s = Matrix(ZZ,[[a,b],[c,d]])
#                         if s^(12) == Matrix(ZZ,[[1,0],[0,1]]):
#                             Stab.append(s)

#     Mn = []
#     for d in divisors(n):
#         if gcd(d, n/d) == 1:
#             for j in [0..d-1]:
#                 Mn.append(Matrix(ZZ,[[n/d,j], [0,d]]))

#     def is_in_SL2Z(Q, gamman, gnp, Stab):
#         # """Returns True if $\gamma_n'\mathrm{Stab(\tau)}\gamma_n^-1
#         # \subset \Sl_2(\Z), and false otherwise"""    
#         flag = True
#         for s in Stab:
#             if Q.matrix_action_left(s) == Q:
#                 Mat = gnp*s*(gamman^-1)
#                 for i in [0..1]:
#                     for j in [0..1]:
#                         if not Mat[i][j].is_integer():
#                             flag = False
#         return(flag)

#     RMn = []
#     for k in [0..len(Mn)-1]:
#         gamman = Mn[k]
#         flag = False                # if True, then there exists some gamma_n'
#                                     # for which is_in_SL2Z is true
#         for gnp in Mn[:k-1]:
#             if is_in_SL2Z(Q,gamman, gnp, Stab):
#                 flag = True
#         if not flag:
#             Q2 = Q.matrix_action_left(gamman)
#             if gcd(f, Q2[0]) == 1:
#                 RMn.append([Q2.reduced_form(), gamman])

#     return(RMn)

# def stable_root(Q):
#     """ Returns stable root of indefinite quadratic form Q
#     """
#     if Q[0] == 0:
#         return(0)
#     return((-Q[1]+sqrt(Q.discriminant()))/(2*Q[0]))

# def compute_Delta_j(psi, S, deltam, d, kj, p):
#     """Computes non-constant terms of diagonal restriction
#     Input:

#     Output: list where the j-th entry is the power series Delta_j

#     """
#     R.<q> = PowerSeriesRing(QQ)
#     DeltaList = []
#     mfrak = psi.conductor()
#     QFlist = BinaryQF_reduced_representatives(mfrak)
#     print(QFlist)
#     for Q in QFlist:
#         RMlist = []
#         for n in [1..S-1]:
#             # print(n)
#             RMset = get_RM_set(n, Q)
#             # print(RMset)
#             if len(RMset) !=0:
#                 RMlist.append(RMset)
#         print("Computed RM sets \n")
#         for j in [0..deltam]:
#             Delta = 0
#             for n in [1..S-1]:
#                 for l in [0..len(RMlist)-1]:
#                     RM = RMlist[l]
#                     print(RM[0])
#                     if RM != []:
#                         Q2 = RM[0]
#                         print("\psi(0)", psi(F(1)))
#                         Delta += q^n *2^d*psi(F(stable_root(Q2[0])))*Q2[0][0]^(kj[j]-1)
#         DeltaList.append(Delta)
#     print("Computed Delta Q = ", Q)

#     return(DeltaList)
#     # Clean this up into consecutive computations


# if __name__ == "__main__":
var('x')
F = NumberField(x^2-2,'a')
p = 3
k0 = 2
m = 6
mfrak = F.modulus(F.ideal(3), [1,1])  # Ray class group
G = HeckeCharacterGroup(mfrak)
try:
    psi = G.gens()[0]
except:
    psi = G.one()
# F.dirichlet_group()[0]
print("F = ", F, "\nG = ", G.group(), "\np = ", p, "\nk0 = ", k0,
      "\nm = ", m, "\npsi = ", psi)
P, Q = diagonal_restriction_Lp(F, p, k0, psi, m,verbose=True)
print("P(s) = ", P)
print("Q(T) = ", Q)
