import time
# import Cython.Compiler.Options
# Cython.Compiler.Options.annotate = True
from sage.all import *
# from sage.rings.rational import Rational
def Delta_data(Q, int n):
    """For a fixed qf Q and an upper bound n, return a list L of
    length n where each L[n] is a list of forms [Qn] similar to
    the output nr_forms of get_RM_set

    """
    
    # assert is_fundamental_discriminant(Q.discriminant()) 
    forms_old, nr_forms = get_RM_set(1,1,[[list(Q),[[1,0],[0,1]]]])
    forms = [forms_old]
    nred_forms = [nr_forms]
    for m in range(2,n+1):
        p = min(divisors(m)[1:]) # smallest prime divisor
        d = m/(p**(valuation(m,p)))
        forms_old, nr_forms = get_RM_set(m,d,forms[d-1])
        forms.append(forms_old)
        nred_forms.append(nr_forms)
    return(nred_forms)
        
        
def get_RM_set(int n, int d, list forms_old):
    r"""Compute the set of RM-points RM(n, tau)_f using algorithm from
    [lauder-vonk2021]_

    Input:
    - $n$ a positive integer.
    - forms_old, a list of pairs [Q_old,gamma_old], where Q_old is a quadratic form of discriminant d^2 *D, and gamma_old a "Hecke matrix" of determinant d
    # - Optionally, $D$ the fundamental discriminant associated to the discriminant of Q_old.
    #
    Output: 
    - 

    Note that the norm of the ideal corresponding to F is precisely
    the first coefficient, a, which is required to be coprime to $f$.

    """



    ######
    # Compute Hecke matrices:
    cdef list Mn = Hecke_matrices(n/d)

    # Initialise some data:

    
    # start_time = time.time()
    cdef list forms_new = []
    cdef int k
    cdef list Q2
    cdef list gamman
    cdef bint flag              # This means binary integer, i.e. boolean
    cdef list gnp               # For our purposes, matrices are lists of lists
    cdef list Qnp
    cdef list nr_forms = []     # list of nearly reduced forms
    # Qlist = []
    for Q_old, gamma_old in forms_old:
        for k in range(len(Mn)):
            gamma_new = mat_mult(gamma_old, Mn[k])
            gamma_new_inv = mat_inv(gamma_new)
            Q_new = matrix_action(Q_old, gamma_new)
            already_seen = False
            # test if our buddy is equivalent to a
            # previously computed friendo:
            for Q, gamma in forms_new:
                eqmat = are_equivalent_mat(Q,Q_new)
                # if Q and Q_new are equivalent over \Q, this computes the matrix E such that
                # Q*E = Q_new
                # print("Eqmat:", eqmat)
                if eqmat:
                    # print(Q, "is equivalent to ", Q_new)
                    Mat = mat_mult(mat_mult(gamma,eqmat), gamma_new_inv)
                    # 
                    # print("Matrix of equiv:", Mat)
                    if (Mat[0][0].is_integer() and
                        Mat[0][1].is_integer() and
                        Mat[1][0].is_integer() and
                        Mat[1][1].is_integer()):
                        already_seen = True
                        break
                        # No point in continuing if we found buddy-guy
                        # doesn't seem to speed up to much?
            # if we have a new friendo, add
            if not already_seen:
                # print(F,gcd(f, F[0]))
                nr_forms += nearly_reduced_forms(list(Q_new))
                forms_new.append([Q_new, gamma_new])
                # add [Q_new,gamma_new] for next iteration

    # end_time = time.time()
    # print(f'Computing RM sets took {end_time - start_time} seconds')
    return([forms_new,nr_forms])

# cdef bint equivalent_pairs(list A, list B):
cpdef list are_equivalent_mat(Q1, Q2):
    F1, U1 = BinaryQF(Q1).reduced_form(transformation=True)
    F2, U2 = BinaryQF(Q2).reduced_form(transformation=True)
    F = F1
    cdef list S = [[1,0],[0,1]]
    cdef int d = floor(F.discriminant().sqrt(prec=30))
    cdef int a,b,c,cabs,sign,s
    while F != F2:
        a,b,c = list(F)
        if c > 0:
            cabs = c
            sign = 1
        else:
            cabs =  -c
            sign = -1
        if cabs >= d:
            s = sign * floor((cabs+b) / (2*cabs))
        else:
            s = sign * floor((d+b) / (2*cabs))
        S = mat_mult(S, [[0,-1],[1,s]])
        # F = F._Rho()
        F = BinaryQF(c, -b + 2*s*c, a - b*s + c*s*s)
        if F == F1:              # if they're not equivalent
            return False
    # print(U1,U2,S)
    return(mat_mult(mat_mult(U1.rows(), S), (mat_inv(U2.rows()))))
    # return(U1*S*U2**-1)

# cdef bint is_in_SL2Z(list Q, int n, list gamman, list gnp):
#     # """Returns True if $\gamma_n'\mathrm{Stab(\tau)}\gamma_n^-1
#     # \subset \Sl_2(\Z), and false otherwise"""

#     cdef list Stab =  [               # Elements of Sl_2(Z)/+-I of finite order.
#         [[1,1],
#          [-1,0]],
#         [[1,0],
#          [0,1]],
#         [[1,-1],
#          [1,0]],
#         [[0,1],
#          [-1,1]],
#         [[0,1],
#          [-1,0]],
#         [[0,1],
#          [-1,-1]] ]
#     cdef list s
#     # cdef matrix Mat # -- not valid type, seems complicated
#     cdef list gamma_ninv = mat_inv_UT(gamman, n)  # no need to do this every time
#     for s in Stab:
#         # Z = matrix_action(Q, s) # no errors found here
#         # print(Z, Q, Z == Q)
#         if matrix_action(Q, s) == Q:  # test if s in stab(Q)
#             Mat = mat_mult(mat_mult(gnp,s), gamma_ninv)
#             # Mat = Matrix(gnp)*Matrix(s)*Matrix(gamman)**-1 # this is slower bc type conversion
#             # Check manually if things are integral:

#             if not (Mat[0][0].is_integer() and
#                     Mat[0][1].is_integer() and
#                     Mat[1][0].is_integer() and
#                     Mat[1][1].is_integer()):
#                 return(False)
                
#     return(True)


cdef list matrix_action(list Q, list A):
     # CF Lammermeyer BQFs p.4
     cdef int r = A[0][0]
     cdef int s = A[0][1]
     cdef int t = A[1][0]
     cdef int u = A[1][1]
     return([Q[0]*r**2 + Q[1]*r*t + Q[2]*t**2,
             2*(Q[0]*r*s + Q[2]*t*u) + Q[1]*(r*u + s*t),
             Q[0]*s**2 + Q[1]*s*u + Q[2]*u**2])



cpdef list mat_mult(list A, list B):
    return([[A[0][0]*B[0][0] + A[0][1]*B[1][0],
             A[0][0]*B[0][1] + A[0][1]*B[1][1]],
            [A[1][0]*B[0][0] + A[1][1]*B[1][0],
             A[1][0]*B[0][1] + A[1][1]*B[1][1]]])

cpdef list mat_inv(list A):
     cdef int n = A[0][0]*A[1][1]-A[0][1]*A[1][0]
     return([[A[1][1]/n, -A[0][1]/n], [-A[1][0]/n, A[0][0]/n]])

cpdef list nearly_reduced_forms(list F):
    Q = BinaryQF(F)
    Q0 = Q.reduced_form()
    Q = Q0                      # no need to keep info about F

    cdef int d = floor(Q.discriminant().sqrt(30))
    cdef list forms = []
    cdef bint started = False
    cdef int a,b,c,s,j
    while Q != Q0 or not started:
        started = True
        # print(Q)
        Q = Q._Rho()            # set Q to be next reduced form in cycle
        a,b,c = list(Q)
        if c > 0:
            cabs = c
        else:
            cabs =  -c
        # now compute s, number of forms on river between previous F and F:
        if cabs > d:
            s = abs(floor(b/(2*cabs)))
        else:
            s = abs(floor((d+b)/(2*cabs)))
        # print("s =", s)
        
        if a > 0:                                 # ensure form added has a>0
            for j in range(1,s+1):
                # print(j)
                # forms.append(F)
                # Fi =  # translate F
                # forms.append(matrix_action([a,b,c],[[1,0],[j,1]]))
                forms.append([a+j*b+j*j*c, b+2*j*c, c])
        else:
            for j in range(1,s+1):
                # print(j)
                # simply flip form if not
                # Fi = 
                forms.append([c, -b+2*j*c, a-j*b + j*j*c])
            
        # F = matrix_action(F, [[0,-1],[1,0]]) # after translating, flip
        
    return(forms)
                
cdef list Hecke_matrices(int n):
    # start_time = time.time()
    # print(n)
    cdef int d
    cdef list Mn = []
    for d in divisors(n):
        if gcd(d, n/d) == 1:
            for j in range(d):
                Mn.append([[d,j], [0,n/d]])
    return(Mn)
                
cpdef list tp_elts_of_trace_n(F, int n, invDiff, int bd):
    """Returns list of totally positive elements of the inverse
    different of F of trace n"""
    a = F.gens()[0]
    # cdef int bd = floor(n*a)
    cdef int b
    cdef list nulist = []
    for b in range(-bd-1,bd+1):
        nu = (b + n*a)/(2*a)
        if nu > 0 and (-b + n*a)/(2*a) >0 and nu in invDiff:
            nulist.append(nu)
        # if F.ideal(nu).is_coprime(m):

    
    # return([(b + n*a)/(2*a) for b in [-bd..bd]])
    return(nulist)
